# -*- coding: utf-8 -*-
"""AppleCounting.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1x83yEJpGtcMdK3a3G91-7IV0zhkevb_9
"""

import cv2 
import numpy as np
from google.colab.patches import cv2_imshow
from google.colab import files
from google.colab import drive
import os
from xml.etree import ElementTree as ET
import random

# !unzip '/content/drive/MyDrive/detection.zip' -d '/content/drive/MyDrive/data/'

!python2 --version





import torch
import torch.nn as nn
print('Torch', torch.__version__, 'CUDA', torch.version.cuda)
print('Device:', torch.device('cuda:0'))
print(torch.cuda.get_device_name(0))

if torch.cuda.is_available():
  device = torch.device("cuda")
  print(device)
else:
  device = torch.device("cpu")
  print(device)

cd /content/drive/MyDrive/data/detection

masks_dir = './train/masks/'
imgs_dir = './train/images/'
save_txt_dir = './train/txt_labels/'
txts_dir = './train/txt_labels/'
save_img_label_dir = './train/img_label/'
Annos_dir = '/content/drive/MyDrive/faster-rcnn.pytorch/data/VOCdevkit2007/VOC2007/Annotations/'
dst_imgs_dir = '/content/drive/MyDrive/faster-rcnn.pytorch/data/VOCdevkit2007/VOC2007/JPEGImages'

def get_file_paths(base_dir):

  everything_in_folder = os.listdir(base_dir)
  all_files = map(lambda x: os.path.join(base_dir,x), everything_in_folder)
  file_list = list(filter(os.path.isfile, all_files))

  return file_list

def get_save_file(dst, capture):

  if not os.path.exists(dst):
      os.mkdir(dst)

  return os.path.join(dst, capture)

def box_and_num(label):

  n_apple = label.max()

  boxs = []
  for i in range(1, n_apple+1):

    pos = np.where(label[:,:,1] == i)
    pos = np.array([pos[0].tolist(), pos[1].tolist()])

    if np.size(pos[0]) != 0:   # miss some labels, so no pixels

      x_min = pos[1].min()
      x_max = pos[1].max()
      x_c = (x_max - x_min)/2

      y_min = pos[0].min()
      y_max = pos[0].max()
      y_c = (y_max - y_min)/2
      

      boxs.append([x_min,y_min,x_max,y_max])
  
  if len(boxs) == n_apple:

    return boxs, n_apple

  else:

    return [], n_apple

def prettyXml(element, indent, newline, level = 0): # elemnt为传进来的Elment类，参数indent用于缩进，newline用于换行 
  if element: # 判断element是否有子元素 
    if element.text == None or element.text.isspace(): # 如果element的text没有内容 
      element.text = newline + indent * (level + 1)  
    else: 
      element.text = newline + indent * (level + 1) + element.text.strip() + newline + indent * (level + 1) 
  #else: # 此处两行如果把注释去掉，Element的text也会另起一行 
    #element.text = newline + indent * (level + 1) + element.text.strip() + newline + indent * level 
  temp = list(element) # 将elemnt转成list 
  for subelement in temp: 
    if temp.index(subelement) < (len(temp) - 1): # 如果不是list的最后一个元素，说明下一个行是同级别元素的起始，缩进应一致 
      subelement.tail = newline + indent * (level + 1) 
    else: # 如果是list的最后一个元素， 说明下一行是母元素的结束，缩进应该少一个 
      subelement.tail = newline + indent * level 
    prettyXml(subelement, indent, newline, level = level + 1) # 对子元素进行递归操作

def xml_generation(dst_imageName, scr_imageName):

  root = ET.Element('annotation')
  folder = ET.SubElement(root, 'folder')
  folder.text = 'VOC2007'

  filename = ET.SubElement(root, 'filename')
  filename.text = dst_imageName + '.jpg'   #imgs_path[0].split('/')[-1]

  source = ET.SubElement(root, 'source')
  database = ET.SubElement(source, 'database')
  database.text = 'The VOC2007 Database'
  annotation = ET.SubElement(source, 'annotation')
  annotation.text = 'PASCAL VOC2007'

  size = ET.SubElement(root, 'size')
  width = ET.SubElement(size, 'width')
  width.text = '720'
  height = ET.SubElement(size, 'height')
  height.text = '1280'
  depth = ET.SubElement(size, 'depth')
  depth.text = '3'

  segmented = ET.SubElement(root, 'segmented')
  segmented.text = '1'


  bndbox_path = os.path.join(txts_dir, scr_imageName + '.txt' ) #imgs_path[0].split('/')[-1].split('.')[0] +'.txt'
  data = np.loadtxt(bndbox_path)
  dim_data = data.ndim
  object = []
  name = []
  pose = []
  truncated = []
  difficult = []
  bndbox = []
  xmin = []
  ymin = []
  xmax = []
  ymax = []

  if dim_data == 1:
    num_bnd = 1
  else:
    num_bnd = data.shape[0]


  for i in range(num_bnd):

      num = str(i+1)
      object.append('object' + num)
      name.append('name' + num)
      pose.append('pose' + num)
      truncated.append('truncated' + num)
      difficult.append('Difficult' + num)
      bndbox.append('bndbox' + num)
      xmin.append('xmin' + num)
      ymin.append('ymin' + num)
      xmax.append('xmax' + num)
      ymax.append('ymax' + num)


  for i in range(num_bnd):

      if num_bnd == 1:
        data = data.reshape(1, 4)

      object[i] = ET.SubElement(root, 'object')
      name[i] = ET.SubElement(object[i], 'name')
      name[i].text = 'apple'
      pose[i] = ET.SubElement(object[i], 'pose')
      pose[i].text = 'Unspecified'
      truncated[i] = ET.SubElement(object[i], 'truncated')
      truncated[i].text = '0'
      difficult[i] = ET.SubElement(object[i], 'difficult')
      difficult[i].text = '0'
      bndbox[i] = ET.SubElement(object[i], 'bndbox')

      xmin[i] = ET.SubElement(bndbox[i], 'xmin')
      xmin[i].text = str(data[i, 0] + 1)
      ymin[i] = ET.SubElement(bndbox[i], 'ymin')
      ymin[i].text = str(data[i, 1] + 1)
      xmax[i] = ET.SubElement(bndbox[i], 'xmax')
      xmax[i].text = str(data[i, 2] + 1)
      ymax[i] = ET.SubElement(bndbox[i], 'ymax')
      ymax[i].text = str(data[i, 3] + 1)


  prettyXml(root, '\t', '\n')     
  tree = ET.ElementTree(root)
  xml_path = os.path.join(Annos_dir, dst_imageName + '.xml' )
  tree.write(xml_path, encoding="utf-8", xml_declaration=True)
  # ET.dump(root)

def generate_train_val_test_txt():
    xml_file_path = "/content/drive/MyDrive/faster-rcnn.pytorch/data/VOCdevkit2007/VOC2007/Annotations"  
    save_Path = "/content/drive/MyDrive/faster-rcnn.pytorch/data/VOCdevkit2007/VOC2007/ImageSets/Main"
    ############################################
    trainval_percent = 0.54
    train_percent = 0.9
    total_xml = os.listdir(xml_file_path)
    num = len(total_xml)
    list = range(num)
    tv = int(num * trainval_percent)
    tr = int(tv * train_percent)
    trainval = random.sample(list, tv)
    train = random.sample(trainval, tr)
    print("train and val size", tv)
    print("train size", tr)
    ##############################################################
    
    ftrainval = open(os.path.join(save_Path,'trainval.txt'), 'w')
    ftest = open(os.path.join(save_Path, 'test.txt'), 'w')
    ftrain = open(os.path.join(save_Path, 'train.txt'), 'w')
    fval = open(os.path.join(save_Path, 'val.txt'), 'w')
    for i in list:                             
        xml_name = total_xml[i][:-4]
        if i in trainval:
            ftrainval.write(xml_name + "\n")
            if i in train:
                ftrain.write(xml_name + "\n")
            else:
                fval.write(xml_name + "\n")
        else:
            ftest.write(xml_name + "\n")
    ftrainval.close()
    ftrain.close()
    fval.close()
    ftest.close()

# txts_path = get_file_paths(txts_dir)   #xml generation
# for idx, file in enumerate(txts_path):
#   print(idx)
#   print(file)
#   scr_img_name = file.split('/')[-1].split('.')[0]
#   src_img_path = os.path.join(imgs_dir, scr_img_name +'.png')
#   img = cv2.imread(src_img_path)
#   dst_img_name = '%06d' % (idx + 1)
#   dst_img_path = os.path.join(dst_imgs_dir, dst_img_name + '.jpg')
#   cv2.imwrite(dst_img_path, img)
#   xml_generation(dst_img_name, scr_img_name)

generate_train_val_test_txt()

cd /content/drive/MyDrive/faster-rcnn.pytorch

!git checkout pytorch-1.0



#saving label in txt file
masks_path = get_file_paths(masks_dir)
for mask in masks_path:

  mask_name = mask.split('/')[-1].split('.')[0] + '.txt'
  save_txt_path = get_save_file(save_txt_dir,mask_name)
  # print(save_txt_path)
  label = cv2.imread(mask)
  boxs, num = box_and_num(label)
  if boxs == []:
    print(mask_name)
  # if boxs != []:
  #   np.savetxt(save_txt_path, boxs) 
  #   print(save_txt_path)

  # 20150921_131453_image401.txt
# 20150919_174151_image171.txt
# 20150921_132038_image361.txt
  # 
  #

# txts_path = get_file_paths(txts_dir)  ## drawing bounding box in images

# for txt in txts_path:

#     img_name = txt.split('/')[-1].split('.')[0] + '.png'
#     img_path = os.path.join(imgs_dir, img_name)
#     print(img_path)

#     img_label = get_save_file(save_img_label_dir, img_name)

#     img = cv2.imread(img_path)
#     boxs = np.loadtxt(txt)

#     for i, box in enumerate(boxs):

#       cv2.rectangle(img,(int(box[0]),int(box[1])),(int(box[2]),int(box[3])),(0,0,255),1)
#       cv2.putText(img, str(i+1), (int(box[0]),int(box[1])),cv2.FONT_HERSHEY_PLAIN, 1, (0, 0, 255), 1)

#     cv2.imwrite(img_label, img)


# label = cv2.imread('./train/masks/20150919_174151_image171.png')
# img = cv2.imread('./train/images/20150919_174151_image171.png')

# a = box_and_num(label)

# print(a)

# for i, box in enumerate(boxs):

#   cv2.rectangle(img,(box[0],box[1]),(box[2],box[3]),(0,255,0),1)
#   cv2.putText(img, str(i+1), (box[0],box[1]),cv2.FONT_HERSHEY_PLAIN, 1, (0, 0, 255), 1)

# cv2_imshow(label)

result = np.loadtxt()



#coding=utf-8
import os
import shutil
import random
from xml.etree.ElementTree import ElementTree,Element
import cv2

def read_xml(in_path):
  '''''读取并解析xml文件
    in_path: xml路径
    return: ElementTree'''
  tree = ElementTree()
  tree.parse(in_path)
  return tree

def check():
    url = "/content/drive/MyDrive/faster-rcnn.pytorch/data/VOCdevkit2007/VOC2007/Annotations" #修改成annotation的目录
    for item in os.listdir(url):
        print(item)
        tree = read_xml(url + "/" + item)
        root = tree.getroot()
        object = root.findall("object")
        size = root.find("size")
        width =int(size.find("width").text)
        height = int(size.find("height").text)
        if object == None:
            print(item)
            continue
        for it in object:
            bndbox = it.find("bndbox")
            if bndbox == None:
                print(item)
            xmin = int(float(bndbox.find("xmin").text))
            xmax = int(float(bndbox.find("xmax").text))
            ymin = int(float(bndbox.find("ymin").text))
            ymax = int(float(bndbox.find("ymax").text))
            if  xmin <= 0 | xmin >= xmax | ymin <=0 | ymin >= ymax:
                print(item)
            if xmax > width | ymax> height:
                print(item)

if __name__ =='__main__':
    check()





# train_labels_dir = './train/masks/'
# save_txt_dir = './train/txt_labels/'

# def get_file_paths(base_dir):

#   everything_in_folder = os.listdir(base_dir)
#   all_files = map(lambda x: os.path.join(base_dir,x), everything_in_folder)
#   file_list = list(filter(os.path.isfile, all_files))

#   return file_list

# def get_save_file(dst, capture)

#   if not os.path.exists(dst):
#       os.mkdir(dst)

#   return os.join.path(dst, capture)

















